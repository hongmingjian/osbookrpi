\documentclass[main.tex]{subfiles}
\onlyinsubfile{\usepackage{CJKutf8}}
\begin{document}
\begin{CJK*}{UTF8}{song}

\chapter{内存管理（上）}
内存管理是操作系统必备的功能之一，也是操作系统实现虚拟化的重要功能。虽然epos是单进程、多线程的操作系统，但是epos支持虚拟内存。目前，虚拟内存一般都是通过分页来实现。
为了跟主流的32位操作系统保持一致，我们让epos内核运行在3GiB之上的逻辑地址空间中，即内核运行在3GiB以上，用户程序运行在3GiB以下的逻辑地址空间中。
BCM2835的内存映射如图所示。其中内存(SDRAM)位于？？？，外围设备控制器的内存映射地址位于?？？。

\section{页表初始化}
对于分页系统，页表是最核心的数据结构。ARMv6支持多种页表组织方式，一级页表分为Section和Page，二级页表分为Large和Small Page。在epos中，一级页表采用Page，二级页表采用Small Page。一级页表的大小是16KiB，共4096项；二级页表的大小是1KiB，共256项；页面大小是4KiB。从地址划分来看，意味着32位的逻辑地址被分成了三段，第一段12位，用于索引一级页表；第二段8位，用于索引二级页表；第三段12位，是页面内部的偏移量。图分别给出了一级和二级页表项的结构。

因为epos是单进程，因此只需要一组页表(包括一个一级页表和多个二级页表)就够了。下面我们就来初始化这组系统唯一的页表。
为了构建页表结构，我们来看一下此时物理内存的使用状况，如图所示。


其中，异常向量表所占的0-0x40共64个字节是从kernel.img的起始64字节拷贝而来。
前面提到，我们要安排epos内核运行在3GiB的位置。也就是说，尽管kernel.img被加载到0x8000的物理内存位置，但要让它在0xc0008000的逻辑地址运行。页表初始化的任务就是把内核自己从加载地址0x8000重定位到逻辑地址0xc0008000上去。
首先，程序的逻辑地址由链接器确定。因此，要告诉链接器，要将内核链接到0xc0008000的位置上，而不是原来的0x8000。这只要修改链接器脚本ldscript.in即可。与图？？相比，只是添加了02行，修改了08行。
\inputminted[linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/kernel.ld.in}

重新编译之后，用objdump查看反汇编的代码，可以发现所有的地址都被加上了0xc0000000。


从理论上来说，kernel.img只有被加载地址0xc0008000才能运行。然而事实上，它将被加载到0x8000的位置，而且也可以运行。其原因在于编译器在产生代码的时候，会尽量用相对地址，例如，\_entry处的几条指令，都是“ldr pc, [pc, \#24]”，这个指令的意思是：把当前PC前面24字节处的4个字节数据作为PC，亦即跳转到当前指令24个字节，即6条指令。其中第二个操作数“[pc, \#24]”的意思就是相对于当前的PC，前面24个字节处的数据。因此，这样的kernel.img即使被加载到0x8000也是可以运行的。
但是，不是所有的操作都可以用相对地址，有时不可避免会产生绝对地址，例如访问全局变量用的是绝对地址。如果程序运行过程中引用了全局变量，就会导致程序出错。因此，需要通过初始化页表，让内核真正运行在被链接的逻辑地址（即0xc0008000）。
函数init\_paging用于初始化页表，参数physfree是空闲物理内存的地址。据前面所述，一级页表大小为16KiB，包含了4096张二级页表的物理地址。根据当前的物理内存使用状况，把一级页表保存在物理内存0x4000处。
\inputminted[firstline=135,lastline=147,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

？？行把一级页表的地址保存在变量pgdir中，然后把一级页表全部清零。
为了在逻辑地址空间中能够访问二级页表，要把它们也映射到逻辑地址空间中来。二级页表需要4MiB的逻辑地址（一张二级页表占1KiB，共4096张）。我们把二级页表放在0xbfc00000。
首先，我们来放置二级页表。由于二级页表本身占用4MiB地址空间，因此要消耗4张二级页表。根据它们所在的逻辑地址，这4张二级页表应该填入页目录的0xbfc, 0xbfd, 0xbfe, 0xbff四项。在填充一级页表项时，标志位L1E\_V表示页表项的格式是Coarse page table，Domain设置为1。后面可以看到Domain=1表示Client，即所有内存访问都必须进行权限检查。注意，其中的“(((uint32\_t)PT)>>PGDR\_SHIFT)”等于0xbfc。

\inputminted[firstline=149,lastline=159,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

需要特别解释一下最后一行，即？？行，它保证了我们可以用地址0xbfeff000来访问ptpte。
接下来，我们为内核的地址空间分配二级页表。尽管内核的地址空间（3GiB-4GiB）需要1024张二级页表，目前我们只给它分配80（即NR\_KERN\_PAGETABLE）张二级页表。一张二级页表可以映射1MiB的地址空间，这意味着可以映射80MiB的逻辑地址空间。当然，我们要把二级页表的物理地址填充到一级页表中，而且所有的二级页表都要清零。此外，还要把新分配的二级页表以页面为单位，填充到ptpte中。注意，我们在填充一级页表的时候，把一级页表的第i项和（i+0xc00）项填充成相同的值，这意味着逻辑地址n和（0xc0000000+n）将被映射到相同的物理地址。二级页表项的标志位L2E\_V表示small page，L2E\_W表示可以读写，L2E\_C表示可以被缓存。

\inputminted[firstline=161,lastline=173,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}


至此，我们准备好了一级和二级页表，下面我们来填充二级页表。如图所示。

一张二级页表有256项，我们需要映射的地址0xc0000000-的逻辑地址映射到0-。

\inputminted[firstline=175,lastline=180,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

根据前面的恒等映射，意味着逻辑地址0-也映射到了0-的物理地址。恒等映射很重要，它保证了分页开启后，可以继续在原来的地址上面运行。当内核完全运行在3GiB之后，就不需要恒等映射，那时将取消恒等映射。


至此，页目录和页表都已经准备完毕。可以开启分页功能。一旦开启分页，所有的逻辑地址将被MMU通过页目录和页表转换成物理地址。TTBR0和TTBR1设置一级页表的物理地址，TTBCR告诉MMU只用TTBR0的一级页表地址。Client设置为0x55555555表示domain全部为01，即所有内存访问都要进行权限检查。最后的 (1|(1<<23))，1表示开启MMU，(1<<23)的字面意思是禁止子页面访问权限检查，但因为只有ARMv4和ARMv5的页表结构支持子页面权限检查，所以设为1表示我们只采用ARMv6格式的页表结构。

\inputminted[firstline=182,lastline=205,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

最后，init\_paging的返回值是空闲物理内存的起始地址。

后面我们需要两个函数：page\_map和page\_unmap，函数page\_map负责把指定的逻辑地址映射到指定的物理地址，而page\_unmap取消这种映射。

\inputminted[firstline=239,lastline=263,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/page.c}

其中，参数flags是页表项的标志位；其中宏定义vtopte(va)返回va所对应的的页表项的指针；函数invlpg(va)的作用是清空TLB缓存中逻辑地址va的缓存项。

\inputminted[firstline=59,lastline=60,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/kernel.h}

好了，现在的逻辑地址空间布局如图所示。

\section{物理内存管理}
首先，我们需要记录硬件系统中物理内存的配置状况。由于不同的机器可以将内存配置在不同的地址，如有些机器的内存配置在[A, B]和[C,D]（其中B≠C）两个区域，有的机器的物理内存配置在[X,Y]一个区域。为此，我们定义一个一维数组g\_ram\_zone，用于记录系统可以使用的物理内存区域。数组g\_ram\_zone[2n]记录了一个内存区域的起始地址，g\_ram\_zone[2n+1]记录了它的结束地址。如果g\_ram\_zone[2n]和g\_ram\_zone[2n+1]都是零，表示后面没有内存区域了。我们给数组g\_ram\_zone预留了16个元素，意味着最多可以保存7个物理内存区域。由于树莓派所有的物理内存都在[0，512MiB]范围内。因此，内存区域的初始化也比较简单。

\inputminted[firstline=207,lastline=216,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

其中的参数physfree是已经使用的内存地址，[0, physfree]部分的内存已经被使用，不能再用于分配。
前面的物理内存区域初始化，比较粗糙，只记录了系统可以使用的物理内存区域。接下来，我们要按照页面单位记录每一个页面的使用状况。因此，我们采用位图（bitmap）数据结构，即一个页面的状态用一位来表示，0表示空闲，1表示已分配。显然，bitmap本身也需要占用物理内存，并且能够在逻辑地址中被访问。因此，我们根据空闲内存的大小，为它分配bitmap，然后映射到逻辑地址空间中来。

\inputminted[firstline=23,lastline=58,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/frame.c}

结构体pmzone记录每一段空闲的物理内存的起始地址、长度和bitmap的指针。Init\_frame的参数brk用于告诉init\_frame逻辑地址空间的空闲位置，该函数新的空闲逻辑地址。为了方便记忆，给出此时物理内存和逻辑地址空间的布局。

下面来实现物理内存的分配功能。

\inputminted[firstline=86,lastline=109,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/frame.c}

有时候我们需要在指定的物理地址的物理内存，所以实现了frame\_alloc\_in\_addr。如果指定的物理内存已经被分配，该函数将失败。

\inputminted[firstline=60,lastline=84,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/frame.c}

下面实现物理内存的回收。

\inputminted[firstline=111,lastline=137,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/frame.c}

这样就实现了一个简单的物理内存管理功能。

\section{逻辑地址空间管理}
不仅物理内存需要管理，逻辑地址空间也需要管理。结构体vmzone记录了逻辑地址空间的起始地址、长度、内存保护标志位。逻辑地址空间结构体通过单项链表进行组织，如图所示。

\inputminted[firstline=24,lastline=36,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/page.c}

全局变量km0用于记录内核自身所占用的逻辑地址空间，kvmzone和uvmzone分别是内核和用户逻辑地址空间链表结构的头节点。
函数init\_vmspace初始化逻辑地址空间结构，参数brk告诉它内核自身的逻辑地址空间结束位置。首先，它初始化了km0，从0xbfc00000到brk，VM\_PROT\_ALL表示这个逻辑地址空间是可读写的。然后，它初始化kvmzone，显然目前只有一个内核逻辑地址空间，即km0，而用户的地址空间是空的，所以把uvmzone初始化为NULL。

\inputminted[firstline=38,lastline=47,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/page.c}

现在我们来实现逻辑地址空间分配的函数，即page\_alloc。参数npages表示分配的页面个数，prot表示该逻辑地址空间的访问标志，user告诉page\_alloc从用户空间还是从内核空间分配。注意，这个函数调用了kmalloc，它用于管理内核堆，请参考4.6.3节。

\inputminted[firstline=112,lastline=174,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/page.c}

跟物理内存分配相同，经常需要在指定的地址分配逻辑地址空间。因此，

\inputminted[firstline=49,lastline=110,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/page.c}

与分配相对应的是回收，

\inputminted[firstline=176,lastline=212,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/page.c}

最后，需要一个函数判断某个逻辑地址是否在某个逻辑地址空间中。如果在，则返回其保护位；否则返回失败。

\inputminted[firstline=214,lastline=237,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/page.c}

\section{缺页异常处理}
前面的内核堆管理中，我们只是为堆分配了逻辑地址空间，没有映射到物理内存。因此，在访问内核堆的时候，会触发data abort异常。如果执行堆中的代码，则会触发prefetch abort。这两个abort都是缺页异常（page fault），data abort是访问数据引起的，而prefetch abort从内存中预取指令时引起的。
缺页异常时实现虚拟内存的关键之一，但是本章不实现虚拟内存的功能，如页面置换、页面交换等，只实现了。
首先，我们去entry.S中修改异常向量表，分别实现prefetch和data abort的异常功能，如图所示。注意，这里我们仍然使用PUSHCONTEXTINSVC和PULLCONTEXTANDEXIT两个宏定义，因为这部分的处理方法与IRQ模式是完全相同的。接着，把发生异常时的CPU现场通过struct context作为第一个参数传递给C语言处理函数abort\_handler。此外，发生abort时两个重要的参数是触发该异常的逻辑地址（Fault Address，FA）和状态码（Fault Status，FS）。因此，接下来两条汇编指令从协处理器读取FA和FS并分别作为第二、三个参数，传递给abort\_handler。
需要特别注意的是，data abort中lr指向的(pc+8)，而prefetch abort中的lr是指向（pc+4），因此在PUSHCONTEXTINSVC中处理之前，先要把lr减掉4才能进行后续的统一处理。

\inputminted[firstline=155,lastline=176,linenos,numbersep=5pt,frame=lines,framesep=2mm]{gas}{chapter04/kernel/entry.S}

现在我们来看看abort\_handler。它只是调用do\_page\_fault处理这个缺页异常，如果do\_page\_fault返回0表示成功处理了该异常，可以继续运行；否则调用panic打印出现场信息，供用户调试使用。

\inputminted[firstline=356,lastline=362,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

所有缺页异常的逻辑都是在do\_page\_fault中处理的。它首先根据code即FS判断触发abort的原因，原因大体上可以分成三类：对齐（alignment），转换（translation），权限（permission）。目前，我们只处理了translation fault，即逻辑地址没有映射到物理内存，导致MMU不能完成地址转换，其他情况则打印出提示信息后返回失败。接着，用page\_prot判断触发异常的地址是否是合法的，即是否在逻辑地址空间中，如果不是，表示程序访问了不该访问的地址。最后，调用frame\_alloc分配一个页面的物理内存，然后修改页表，把触发异常的逻辑地址映射到新分配的物理内存上。注意，对于二级页表本身引起的缺页异常，需要把新分配的二级页表物理地址填充到一级页表中。如果没有空闲的物理内存，打印提示信息后返回失败。

\inputminted[firstline=245,lastline=354,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

至此，我们把内存管理部分的工作完成了。

\section{内存管理初始化}
前面把epos目前所具有的内存管理功能全部列出来了。下面我们把这些功能组合起来，完成内存管理系统的初始化工作。
\subsection{修改栈地址}
在本章之前，我们在entry.S中为各个模式所设置的栈位于0x4000之下，因为内核被链接到了0xc0000000之上，也要相应地修改栈的地址，将来才能以链接地址运行。修改方法是在原来的地址上，全部加上内核基地址，即KERNBASE。注意，我们没有修改SVC模式的栈，因为在内核尚未开启分页之前，CPU运行在SVC模式，且需要用到SVC栈。而其他模式栈，当启用分页之后才会访问，可以先行修改。SVC模式栈将在开启分页以后进行修改，请参考4.6.2节。

\inputminted[firstline=125,lastline=142,linenos,numbersep=5pt,frame=lines,framesep=2mm]{gas}{chapter04/kernel/entry.S}

\subsection{启用分页}
先解释一下end这个变量。它是一个比较特殊的变量，它不是在程序中定义的，而是在链接器脚本kernel.ld.in中定义的。它记录了链接完成后这个程序最后的地址，end之前是程序的代码、数据等信息，end标记了这些信息的结束。也就是说，end标记了程序的结束地址。因此，？？行中的变量\_end保存了程序的结束地址。PAGE\_ROUNDUP是把一个整数向上取到页面大小（即4096）的倍数。宏定义R(x)把地址x减去内核的起始基地址，即0xc000000。因此，？？行的physfree保存了内核被加载到物理内存的结束地址，亦即空闲物理内存的起始地址。
\inputminted[firstline=368,lastline=373,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}
因为init\_paging要消耗掉一些物理内存，因此它返回了新的空闲物理内存的起始地址。
函数init\_paging运行完成后，内核可以运行在3GiB的地址上，是时候调整SVC模式栈的地址了。

\inputminted[firstline=375,lastline=378,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

\subsection{内核堆初始化}
在内核运行过程中，也经常需要动态地分配和释放内存。因此，内核堆对于内核的运行是非常必要的。对于堆的管理算法，我们采用了第三方的堆管理器TLSF（Two Level Segregated Fit memory allocator）。首先调用init\_frame初始化物理内存管理器，接着调用init\_vmsapce初始化逻辑地址空间，然后才能调用init\_kmalloc初始化内核堆，堆的初始大小为4MiB。注意，我们只是给堆分配了地址空间，并未分配物理内存，将来访问堆时，通过4.5节实现的缺页异常处理，自动完成物理内存的分配以及逻辑地址到物理内存的映射。

\inputminted[firstline=380,lastline=394,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

\subsection{外设地址映射}
在第二、三章中，我们通过基地址MMIO\_BASE\_PA=0x20000000来访问外设。打开分页之后，不能再直接通过这种地址去访问外设了。为此，要把位于0x20000000-0x21000000的物理内存映射到逻辑地址空间中来，然后才能用逻辑地址去访问串口、定时器等外设。问题是，要把外设地址映射到那个逻辑地址位置呢？我们前面讲到，因为只给内核分配了80张二级页表，只能映射80MiB地址空间，即0xc0000000-0xc5000000。所以，我们选择MMIO\_BASE\_VA=0xC4000000，这样外设所在的逻辑地址是0xc4000000-0xc5000000。选择了映射地址之后，要通过page\_alloc\_in\_addr把这一段逻辑地址空间保留下来。需要特别注意的是，在调用page\_map映射外设地址空间时，第三个参数flags不能带L2E\_C，这是因为外设的存储不能被缓存。

\inputminted[firstline=396,lastline=401,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

除此之外，还得把machdep.c中的“MMIO\_BASE\_PA+AUX\_REG”的地方全部改为“MMIO\_BASE\_VA+AUX\_REG”，这样才能正确访问外设。

\subsection{开启HiVecs功能}
在ARM早期的版本中，异常向量只能在地址0，也就是说当发生IRQ时，PC=0x18；data abort时PC=0x10；prefetch abort时PC=0xc等等。所以，操作系统至少必须保留逻辑地址空间的第一个页面，把异常向量放在里面。在ARM720T之后，支持所谓的HiVecs，即异常向量可以在地址0xffff0000。开启HiVecs后，当发生IRQ时PC=0xffff0018，data abort时PC=0xffff0010，prefetch abort时PC=0xffff000c等等。
因此，我们先把0xffff0000-0xffff1000这个页面用page\_alloc\_in\_addr保留下来，然后用page\_map把它映射到物理内存的0地址（因为异常向量表保存在物理地址0的位置）。这样就把异常向量搬到了0xffff0000地址上去，然后通过修改系统控制寄存器SCTLR开启hivecs模式。

\inputminted[firstline=403,lastline=420,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

\subsection{取消恒等映射}
经过上面的初始化步骤，我们的内核已经运行在事先设定的逻辑地址空间之中，是时候清理一下逻辑地址空间了。首先，内核已经不再需要恒等映射，通过把把一级页表PTD中的前80项全部清零，即取消了恒等映射。恒等映射保证了内核顺利地从加载地址过渡到链接地址，其作用就像初生胎儿的脐带，生产之后必须切断，走出作为独立个体的第一步。接下来，取消0xc0001000-0xc0004000之间的地址空间(0xc0000000-0xc0001000是各个模式的栈，不能取消；0xc0004000-0xc0008000是一级页表，也不能取消)。最后，清空整个TLB缓存，以使修改立即生效。

\inputminted[firstline=422,lastline=431,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter04/kernel/machdep.c}

至此，逻辑地址空间的布局如图所示。物理内存的布局如图所示。

\clearpage
\end{CJK*}
\end{document} 