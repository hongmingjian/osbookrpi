\documentclass[main.tex]{subfiles}
\onlyinsubfile{\usepackage{CJKutf8}}
\begin{document}
\begin{CJK*}{UTF8}{song}

\chapter{系统启动}
BCM2835/6/7作为系统芯片（SoC），除了CPU和内存之外，还集成了GPU、USB、UART等外设。为了减少成本，树莓派没有采用类似于IBM-PC机的BIOS固件，而是把固件保存在外置的SD/MicroSD卡中。当系统加电时，CPU处于停止状态，GPU从SoC内部的ROM芯片读取第一阶段引导程序并执行。第一阶段引导程序负责从SD卡的第一个FAT文件系统中加载第二阶段引导程序bootcode.bin，由它加载第三阶段引导程序start.elf。start.elf读取并解析配置文件config.txt，然后加载kernel.img到0x8000的内存位置。至此，GPU完成了系统引导工作，然后复位CPU，由CPU执行0x8000位置的kernel.img。注意，不要被扩展名所迷惑，其实kernel.img是一个无格式的二进制可执行文件。

\section{Hello world!}
为了验证各项准备工作都已经到位，先编写一个简单程序，向串口输出“Hello world!”。首先，我们需要初始化串口，代码如1-1所示。

\inputminted[firstline=6,lastline=30,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter02/kernel/machdep.c}

这个函数首先设置了串口的数据位和波特率，然后将GPIO的14和15口配置为串口的收发口。如果你不理解这些代码是怎么工作的，没有关系，现在不需要深入每个细节，它们不影响你对关键内容的理解。初始化完成后，可以用轮询的方式向串口输出字符。代码如下：

\inputminted[firstline=32,lastline=41,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter02/kernel/machdep.c}

\par

接下来编写内核的入口，即CPU执行的第一条指令。首先，新建一个文件entry.S，注意扩展名是大写的S。GNU汇编器（gas）来编译汇编文件时，对于以大写S为扩展名的汇编文件，会先对源程序用C预处理进行预处理，而扩展名为小写s的汇编文件，不会进行预处理。文件entry.S的内容如下：

\inputminted[linenos,numbersep=5pt,frame=lines,framesep=2mm]{gas}{chapter02/kernel/entry.S}

entry是系统的入口点，当CPU复位时，即从entry开始执行，它只是简单做了一个跳转，跳到reset处开始执行。首先，我们初始化栈，因为后续的函数调用需要用栈来保存一些临时变量。我们把栈放在0x1000的位置，注意栈是向低地址增长的。栈初始化完成后，立即跳转到C语言的函数cstart开始完成后续的初始化工作。细心的读者可能注意到了，cstart为什么要在前面加入一个下划线？历史上，C语言编译器为全局变量或者函数的符号前面加入一个下划线，我们保留这个传统。所以，C语言中定义的全局函数cstart，在汇编中要用\_cstart引用它。反过来也一样，如果汇编语言定义的全局变量或者函数要被C语言调用，在名字前面也要加上一个下划线。

\par
cstart函数比较简单，它首先初始化串口，波特率设置为9600，然后循环调用sys\_putchar把事先定义好的字符串“Hello, world!”打印出来。最后，我们通过一个无限空循环让控制停cstart函数中。

\inputminted[firstline=42,lastline=54,linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter02/kernel/machdep.c}

\section{编译}
代码已经写完了，接下来我们要对它们进行编译。作为操作系统内核，编译的方法也不同于普通的应用程序。具体命令如下：
\mint[breaklines]{bat}@arm-none-eabi-gcc -Wall -O2 -nostdinc -I../include -c -o entry.o entry.S@
\mint[breaklines]{bat}@arm-none-eabi-gcc -Wall -O2 -fomit-frame-pointer -ffreestanding -fno-stack-check -fleading-underscore -nostdinc -I../include -c -o machdep.o machdep.c@

编译选项解释如下：
\begin{itemize}
	\item -Wall告诉编译器输出所有的警告信息
	\item -O2表示编译时采用2级优化
	\item -nostdinc表示不要使用标准的头文件搜索目录，包括编译器自带的或宿主机操作系统的头文件。标准头文件一般是为普通应用程序准备的，一般不适合于操作系统内核这种独立的软件。
	\item -I../include表示把路径../include加入到头文件搜索目录。这个目录下面的文件包含了编译内核需要的头文件。
	\item -c表示只是编译不执行链接
	\item –o entry.o告诉编译器输出的目标文件名
	\item -ffreestanding告诉编译器不要使用标准函数库，程序的入口函数也不是main。操作系统内核一般不能使用编译器或者宿主机操作系统提供的库函数，而且我们的入口函数是entry.S中定义的entry，不是函数main。
	\item -fleading-underscore表示在C语言中定义的全局变量或函数符号的前面加一个下划线。
    \item -fomit-frame-pointer
    \item -fno-stack-check
\end{itemize}

\section{链接}
链接的过程就是把多个目标文件，组装成一个可执行程序的过程。组装的方法是把各个目标文件中代码、数据中相同类型的数据放在一起，然后解析全局变量的引用和函数的互相调用关系。链接器是根据链接脚本(linker script)进行工作的。对于普通应用程序，编译器会提供一些默认的链接器脚本。但是，操作系统内核不能用跟普通应用程序相同的方法进行链接。所以，我们需要自己编写一个链接器脚本，如下所示。

\inputminted[linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter02/kernel/kernel.ld.in}

链接器脚本可以使用C语言的宏定义，在交给链接器之前，我们会先对脚本进行预处理。
预处理的命令如下：
\mint{bat}@arm-none-eabi-gcc -E -P -x c-header -o kernel.ld kernel.ld.in@
选项-E，-P，-x。有了链接器脚本，下面可以进行链接：

\mint[breaklines]{bat}@arm-none-eabi-gcc -Tkenrel.ld -nostdlib -nostartfiles -nodefaultlibs entry.o machdep.o -o kernel.elf@

链接器的输出是一个ELF格式的可执行程序。为了验证编译器是否生成了正确的代码，可以用objdump进行反汇编，
\mint[breaklines]{bat}@arm-none-eabi-objdump -d kernel.elf@
结果如图所示。可以看出，指令从0x8000开始，右边的汇编指令与entry.S完全一致。

\includegraphics[scale=0.8]{1.png}

kernel.elf是一个ELF格式的可执行程序，而树莓派只能加载无格式的二进制可执行文件。我们用objcopy把ELF格式信息剥离，只留下可执行代码。命令如下：
\mint[breaklines]{bat}@arm-none-eabi-objcopy kernel.elf -O binary kernel.img@

\section{运行}
把kernel.img复制到SD卡根目录，把SD卡插入树莓派，能够看到在串口输出中看到“Hello world！”。

\includegraphics[scale=0.8]{2.png}

\section{提高效率}
如果你看到了“Hello, world!”，那么恭喜你，你的开发环境已经没有问题，可以继续开发。但是，我们发现代码写完之后，需要敲很多命令才能完成编译、链接等工作，效率很低，也非常容易出错。为此，我们采用GNU make作为项目管理工具，帮我们处理编译、链接等繁琐的工作。Make需要我们提供一个Makefie来告诉它如何完成这些工作。Makefile如图所示。其中1-？行是变量定义，后面的格式是

\par
目标：依赖1 依赖2 ......
	动作

\par
有了make和Makefile，只要运行make，它会自动生成第一个目标，即kernel.img，如果第一个目标依赖于其他目标，它会递归执行动作，直到所有的依赖都得到满足，最后执行动作生成kernel.img.  “make 目标”，比如make kernel.img，make clean会删除所有生成的文件。如果不带目标，直接运行make，默认构建第一个目标，即kernel.img。

\inputminted[linenos,numbersep=5pt,frame=lines,framesep=2mm]{make}{chapter02/kernel/Makefile}

\section{小结}
本章我们通过实现一个非常简单功能，一方面验证了整个开发环境，另一方面也初步掌握了操作系统内核的开发流程，为后续进行更复杂的开发工作奠定了基础。

\iffalse
    \section{调试}
    为了方便调试，经常需要输出一些格式化的数据，为此我们找了第三方的函数snprintf【】来实现格式化输出的功能。注意，该函数不支持浮点数的格式化输出。

    \inputminted[linenos,numbersep=5pt,frame=lines,framesep=2mm]{c}{chapter02/kernel/printk.c}
\fi

\clearpage
\end{CJK*}
\end{document} 